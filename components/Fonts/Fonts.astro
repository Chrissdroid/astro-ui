---
export interface Props {
  name: string;
  styles?:string[] | string;
  weights?: number[] | string;
  local?:boolean;
  remote?:boolean;
}
import fs from 'node:fs'
import fsp from 'node:fs/promises'
import path from 'node:path'


   

let {name, weights, styles, local, remote} = Astro.props as Props;

const API = `http://google-webfonts-helper.herokuapp.com/api/fonts`
const APIRequest = async (id:string):Promise<JSON>=> await fetch(`${API}/${id}?subsets=latin,latin-ext`).then(res=>res.json());

const getfonts = async():Promise<object>=>{
  let data
  try{
    data = await fetch('http://google-webfonts-helper.herokuapp.com/api/fonts/').then(
    response=>response.json()
    ).then( 
      result=>(
        result.reduce((fonts,item)=>{
          fonts[item.family] = item
          return fonts
        },{})
      )
   )
  }catch(err){
    console.error('Error Fetching from the Google Fonts API:', err)
  }finally{
    return data
  }
}
const styleRule = (data):string=> {
  const {fontFamily,fontStyle,fontWeight,woff2}=data
  const saveName = `${name.toLocaleLowerCase()}-${fontStyle.toString()}-${fontWeight.toString()}`
  return `
  /** ${fontFamily.replace('\'','').replace('\'','')}[${fontWeight}] - ${fontStyle} */
  @font-face {
    font-family: ${fontFamily};
    font-style:  ${fontStyle};
    font-weight: ${fontWeight};
    src: ${local ? ` url('/fonts/${name}/${saveName}.woff2') format('woff2'); /* Chrome 26+, Opera 23+, Firefox 39+ */ `
        :`url('${woff2}')`} format('woff2'); /* Chrome 26+, Opera 23+, Firefox 39+ */
  }` 
}

const extractMeta = (data):object=> {
  const {fontStyle,fontWeight,woff2}=data
  const saveName = `${name.toLocaleLowerCase()}-${fontStyle.toString()}-${fontWeight.toString()}`
  return {
    relPath: saveName,
    woff2,
    }
}

const filter = (styles,weights):Array<object>=>{
  let arr = []
  if(!Array.isArray(styles)){
    styles = [styles]
  }
  if(!Array.isArray(weights)){
    weights = [weights]
  }
  for(let weight of weights.sort()){
    for(let style of styles){
     arr.push(
      [... variantData.filter(variant=> variant.fontStyle == style).filter(variant=>variant.fontWeight == weight)]
       )
    }
  }
  return arr
}

const checkAccess = async(path:string):Promise<Boolean> =>{
  try {
    await fsp.access(path, fs.constants.F_OK)
    return true
  } catch (error) {
    return false
  }
}
const createDir = async(path:string)=> await fsp.mkdir(`${path}`,{recursive:true}).catch(e=>console.error("Error Creating File To Disk:",e)) 
const createFile = async(path:string,data:any)=>{
  try {
    return await fsp.writeFile(path,data,'utf-8')
  } catch (error) {
    console.error("Error Writing Font Stylesheet to Disk:",error)
  }
}
const savetoCSS = async (data,subdir?)=>{
  const fontsDir = path.join(`${process.cwd()}/public/fonts`,subdir)
  const fileName = `${name.toLocaleLowerCase()}.css`
  try {
    if(!(await checkAccess(fontsDir))){
      await createDir(fontsDir)
    }
    if(!(await checkAccess(path.join(fontsDir,fileName)))){
      await createFile(path.join(fontsDir,fileName),data)
    }
  } catch (error) {
    console.error("Error saving font to CSS:",error)
  }
}
const downloadFontFile = async(fontURL,subdir,saveName,ext)=>{
  try {
    const filePath = path.join(`${process.cwd()}/public/fonts`,subdir)
    const savedPath = `${filePath}/${saveName.toLowerCase()}.${ext}`
    if(!(await checkAccess(filePath))){
      await createDir(filePath)
    }
    if(!(await checkAccess(savedPath))){
      const data = await fetch(fontURL).then(
        res=> res.arrayBuffer()
      ).then(
          buffer=> new Uint8Array(buffer)
      )
       return await createFile(savedPath,data)
    } 

  } catch (error) {
    console.error("Error Downloading Font File:",error)
  }
}
const variantData = []
const runBuild=async()=>{
  const fonts = await getfonts()
    let rules,meta
    if(name in fonts){
      const {id} = fonts[name]
      const data = await APIRequest(id)
      for(const variant of data.variants){
        variantData.push(variant)
      }
    }
    let filteredList = filter(styles ?? 'normal',weights ?? '400').flat(2)
    rules = filteredList.map((item)=> styleRule(item))
    meta = filteredList.map((item)=> extractMeta(item))
    if(!remote){
      await savetoCSS(rules.join('\n'),name)
    }
    if(local){
      for(let item of meta){
        await downloadFontFile(item.woff2,name,item.relPath,'woff2')
      }
    }
}

if(!(fs.existsSync(path.join(process.cwd(),'public','fonts',name))) || import.meta.env.SSR){
 await runBuild()
}


---

{
  remote 
  ? `
    <!-- External Font: '${name}' via HTTPS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href='https://fonts.googleapis.com/css2?family=${name}${(weights && Array.isArray(weights)) ? ':wght@' + weights.join(';') : (weights && typeof weights === 'string') ? weights : '400'}&display=swap' rel="font"> 
    <!-- End of Font -->
  `
  : `<!-- External Font: '${name}' via CSS -->
    <link rel="stylesheet" href="/fonts/${name}/${name.toLowerCase()}.css">
  <!-- End of Import -->` 
}