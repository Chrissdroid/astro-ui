---
const {
	'@is': tag = null,
	...attrs
} = Astro.props

type Tag = keyof HTMLElementTagNameMap | (string & {})

const XElement: string = tag === null ? 'span' : tag

/** Formats the given value so that it can be placed into an attribute. */
const toAttributeString = (value: any) => String(value).replace(/&/g, '&#38;').replace(/"/g, '&#34;')

/** Listeners attached to the event. */
let listenerString = ''

/** Event fired once before the document is displayed, deferred using `type="module". */
let listenerOfOnce = ''

for (const name in attrs) {
	if (name.startsWith('@')) {
		const data = attrs[name]

		if (typeof data === 'function') {
			delete attrs[name]

			/** Normalized type of the event. */
			let type = name.slice(1)

			/** Options extracted from the type. */
			let opts: { [key: string]: boolean } = {}

			/** Values extracted from the type to populate Options. */
			let read: RegExpExecArray

			while ((read = /:\w+$/.exec(type))) {
				opts[type.slice(read.index + 1)] = true

				type = type.slice(0, read.index)
			}

			switch (type) {
				case 'once':
					listenerOfOnce = `(${toAttributeString(data)})($);`
					break

				case 'resize':
					listenerString += `new ResizeObserver((e,o)=>${
						opts.once
							? `!o.disconnect()&&`
						: ``
					}(${toAttributeString(data)})(e[0])).observe($);`
					break

				case 'visible':
					listenerString += `new IntersectionObserver((e,o)=>e[0].isIntersecting${
						opts.once
							? `&&!o.disconnect()`
						: ``
					}&&(${toAttributeString(data)})(e[0])).observe($);`
					break

				default:
					listenerString += `$.addEventListener(${toAttributeString(`"${type}"`)},${
						opts.prevent
							? `e=>{e.preventDefault();(${toAttributeString(data)})(e)}`
						: toAttributeString(data)
					}${
						opts.once ? ',{once:true}' : ''
					});`
			}
		}
	}
}

const onLoadString: string = listenerString || listenerOfOnce ? `(function(){let $=this;${
	listenerString
}${
	listenerOfOnce
}}).call(this.previousSibling,this.remove())` : null

export interface Props {
	/** A string indicating the type of element being created. */
	'@is'?: Tag

	/** A function used to reference the DOM Node for this element. */
	'@once'?: (
		/** DOM Node representing this element. */
		element?: HTMLElement
	) => void
}
---
<XElement {...attrs}><slot /></XElement>{
	onLoadString && <script type="module" src="data:text/javascript," onload={onLoadString} />
}