---
import { Fragment } from 'astro/internal'
import { createRequire } from 'node:module'

const require = createRequire(import.meta.url)
const { transformWithEsbuild } = require('vite')

const {
	'@is': tag = null,
	...attrs
} = Astro.props

/** Generates the HTML Tag for the Element */
const XElement: string = tag == null || /^(#text|fragment)$/i.test(tag) ? Fragment : tag

/** Formats the given value so that it can be placed into an attribute. */
const toAttributeString = (value: any) => String(value).replace(/\b__vite_ssr_dynamic_import__\b/, 'import').replace(/\b__vite_ssr_import_0__\.default\b/, 'fetch')

/** Listeners to attach onto the event. */
let listenerString: string = ''

/** Event fired once before the document is displayed, deferred using `type="module". */
let listenerOfOnce: string = ''

let defineVarsString: string = ''

/** Returns the null-safe type of value. */
const typeOf = (value: any) => value === null ? 'null' : typeof value

/** Returns the function-safe serialized value. */
const serialize = (value: any) => {
	switch (typeOf(value)) {
		case 'function':
			return String(value)

		case 'object':
			return (
				Array.isArray(value)
					? `[${
						Object.values(value).map(serialize)
					}]`
				: value instanceof RegExp
					? String(value)
				: `{${
					Object.keys(value).map(
						name => `${JSON.stringify(name)}:${serialize(value[name])}`
					)
				}}`
			)

		default:
			return JSON.stringify(value)
	}
}

/** Parse the Attributes */
for (const name in attrs) {
	if (name.startsWith('@')) {
		const data = attrs[name]

		if (typeOf(data) === 'function') {
			delete attrs[name]

			/** Normalized type of the event. */
			let type = name.slice(1)

			/** Options extracted from the type. */
			let opts: { [key: string]: boolean } = {}

			/** Values extracted from the type to populate Options. */
			let read: RegExpExecArray

			while ((read = /:\w+$/.exec(type))) {
				opts[type.slice(read.index + 1)] = true

				type = type.slice(0, read.index)
			}

			/** Apply the JS payload delivery*/
			switch (type) {
				case 'do':
					listenerOfOnce = `(${toAttributeString(data)})($,$$);`
					break

				case 'resize':
					listenerString += `new ResizeObserver((e,o)=>${
						opts.once
							? `!o.disconnect()&&`
						: ``
					}(${toAttributeString(data)})(e[0],$$)).observe($);`
					break

				case 'observe':
					listenerString += `new MutationObserver((e,o)=>${
						opts.once
							? `!o.disconnect()&&`
						: ``
					}(${toAttributeString(data)})(e[0])).observe($,${
						opts.attr ?
							`attributes:true`
						: opts.children ?
							`childList:true`
						: opts.sub ?
							`subtree:true`
						: opts.data ?
							`characterData:true`
						: `attributes:true,childList:true,subtree:true,characterData:true`
						});`
					break

				case 'visible':
					listenerString += `new IntersectionObserver((e,o)=>e[0].isIntersecting${
						opts.once
							? `&&!o.disconnect()`
						: ``
					}&&(${toAttributeString(data)})(e[0],$$)).observe($);`
					break

				default:
					// Add Event Listeners
					listenerString += `$.${
						opts.remove ?`removeEventListener` : `addEventListener`
					}(${
						JSON.stringify(type)
					},${
						`e=>{${
							opts.prevent ? `e.preventDefault();` : ''
						}(${
							toAttributeString(data)
						})(e,$$)}`
					}${
						opts.once
							? ',{once:true}'
						: opts.useCapture
							? `,{useCapture:true}`
						: ''
					});`
					break
			}
		} else if (name.includes('@animate') && typeOf(data) === 'object') {
			/** Applying Web Animate API to the Element */
			const [ keyFrames, options ] = [
				attrs['@animate'],
				attrs['@timings']
			]

			delete attrs['@animate']
			delete attrs['@timings']

			listenerString += `$.animate(${
				JSON.stringify(keyFrames)
			},${
				JSON.stringify({ ...options })
			});`
		} 
	}

	if (name.includes('define:vars')){
		const data = attrs['define:vars']

		if (typeOf(data) === 'object') {
			defineVarsString = `let ${
				Object.entries(data).map(
					([ name, value ]) => `${name.replace(/[^\w]/g, '')}=${
						serialize(value)
					}`
				).join(',')
			};`
		}
<<<<<<< HEAD

		delete attrs['define:vars']
	}
}

/** Transforms the JS/TS input using ESBuild */
const transformer = async (code: string): Promise<string> => await transformWithEsbuild(code, 'xelement.ts', { minify: true }).then(result => result.code)
=======
<<<<<<< Updated upstream
	}
}

const onLoadString: string = listenerString || listenerOfOnce ? `(function(){let $=this,$$=(await import(\'${dataURI}\')).default, fetch = window.fetch;${
	listenerString
};${
	listenerOfOnce
}}).call(this.previousSibling,this.remove())` : null
=======
		 else if(name.includes('@imports') && data){
			/** Import modules and external files into the Element */
			let buffer = []

			const importStatement = (name,src,importName,type=null) => `${name}=(await import("${src}"))${type === 'default' ?`.default` : `["${importName}"]`}`

			const importStatements = (statements) => `const ${statements.map(
  					statement => importStatement(statement.constName,statement.src, statement.importName, statement?.type )).join(',')}`
			
			for (let [names, path] of Object.entries(data)) {
				names.split(',').map(name=>{
					if (name.includes(':default')){
						let o = name.replace(':default','')
						return buffer.push({
							constName:o,
							importName:o,
							src: path,
							type:'default',
						})
					}else if(name.match(/[\w:\w]/)){
						let o = name.split(':')
						console.log(o)
						return buffer.push({
						constName:o[1] ?? o[0],
						importName:o[0],
						src: path,
					})
					}
					return buffer.push({
						constName:name,
						importName:name,
						src: path,
					})

				})
			}
			importString = importStatements(buffer)
			delete attrs['@imports']
		}else if(name.includes('@import:http') && name.includes('@import:key')){
				delete attrs['@import:http'] 
				delete attrs['@import:key'] 

		}else if(name.includes('@props') && data && typeof data ==='object'){
			const buffer = Object.entries(data)
			const propStatement =(key,value)=> `prop_${key} = ${
				typeof value ==='object'? toAttributeString(JSON.stringify(value)) : toAttributeString(value)}`
			const propsStatements =(statements) => `const ${statements.map(prop=>propStatement(prop[0],prop[1]))}
			`
			
		  propsString = propsStatements(buffer)
			delete attrs['@props']
		}
	}
}

const onLoadString: string = listenerString || listenerOfOnce ? `(async function($$,$){$=this;$$=(await import($$.src)).default;${importString ?? ''};${propsString ?? ''};${fetchAPI};${
	listenerString
};${
	listenerOfOnce
}}).call(this.previousSibling,this.remove()||this)` : `(async function($$,$){$=this,$$=(await import($$.src)).default;${importString ?? ''}}).call(this.previousSibling,this.remove()||this)`

const Template = 'template'
>>>>>>> Stashed changes
>>>>>>> www-xelement

/** Create a hashmap to store the transformed code */
const hash = Object.create(null)

/** Return transformed code, remembering previously transformed code. */
const memo = async (code: string) => {
	// if the hashmap has the transformed code for this code, return it
	if (code in hash) return hash[code]

	// otherwise, the transform code and assign it to the hashmap
	hash[code] = await transformer(code)

	// and return the transformed code
	return hash[code]
}

const onLoadString: string = (
	listenerString || listenerOfOnce
		? await memo(
			`(async function($$,$){$=this;$$=(await import($$.src)).default;${
				defineVarsString ?? ''
			}${
				listenerString ?? ''
			}${
				listenerOfOnce ?? ''
			}}).call(this.previousSibling,this.remove()||this)`
		)
	: ''
)

/** Matching ShadowRoot attribute. */
let shadowRoot = Object.keys(attrs).find(name => /^shadowroot$/i.test(name))

if (shadowRoot) {
	/** Formatted ShadowRoot attribute value */
	let value = attrs[shadowRoot]

	// format the ShadowRoot attribute value
	value = typeof value === 'string' ? value : value ? 'open' : 'closed'

	// remove it from the attributes sent to the main element
	delete attrs[shadowRoot]

	// update the shadowRoot attribute value
	shadowRoot = value
}

const AstroFragment = Fragment as unknown as string
const HtmlTemplate = 'template'
---
<XElement {...attrs}>{
	shadowRoot
		? <HtmlTemplate {shadowRoot}><slot /></HtmlTemplate>
	: XElement === AstroFragment
		? <slot>&#8203;</slot>
	: <slot />
}</XElement>{
	onLoadString
		? <script type="module" src="data:text/javascript,export default {}" onload={
			onLoadString
		} />
	: null
}