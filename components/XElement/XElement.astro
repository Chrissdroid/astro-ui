---
/**
 *
 *
 *   __  __ _____  _                                _
 *   \ \/ /| ____|| |  ___  _ __ ___    ___  _ __  | |_
 *    \  / |  _|  | | / _ \| '_ ` _ \  / _ \| '_ \ | __|
 *    /  \ | |___ | ||  __/| | | | | ||  __/| | | || |_
 *   /_/\_\|_____||_| \___||_| |_| |_| \___||_| |_| \__|
 *
 * 			Web Component Generator For Astro
 *
 * @description XElement is a lightweight Web component generator for Astro
 * which allows you to specify which HMTL compliant you wish to generate. It
 * also allows for specialised delivery of JS to the Client, respecting
 * Astro's Islands ethos.
 *
 * @copyright 2021
 * @license GNU3 General Public License version 3
 * @author jonathantneal - https://github.com/jonathantneal
 * @author aFuzzyBear - https://github.com/aFuzzyBear
 *
 */

//Type Definitions

/** @typedef Tag - Valid HTML Tag names */
type Tag = keyof HTMLElementTagNameMap | (string & {})

export interface Props {
	'@is': Tag
	attrs?: any
}

const dataURI = `data:text/javascript,export default {}`

const {
	'@is': tag = null,
	...attrs
} = Astro.props as Props


/** Generates the HTML Tag for the Element */
const XElement: string = tag === null ? 'span' : tag

/** Formats the given value so that it can be placed into an attribute. */
const toAttributeString = (value: any) => String(value).replace(/&/g, '&#38;').replace(/"/g, '&#34;')

/** Listeners to attach onto the event. */
let listenerString = ''

/** Event fired once before the document is displayed, deferred using `type="module". */
let listenerOfOnce = ''

/** Parse the Attributes */
for (const name in attrs) {
	if (name.startsWith('@')) {
		const data = attrs[name]

		if (typeof data === 'function') {
			delete attrs[name]

			/** Normalized type of the event. */
			let type = name.slice(1)

			/** Options extracted from the type. */
			let opts: { [key: string]: boolean } = {}

			/** Values extracted from the type to populate Options. */
			let read: RegExpExecArray

			while ((read = /:\w+$/.exec(type))) {
				opts[type.slice(read.index + 1)] = true

				type = type.slice(0, read.index)
			}
			/** Apply the Hydration selectors*/
			switch (type) {
				case 'do':
					listenerOfOnce = `(${toAttributeString(data)})($,$$);`
					break

				case 'resize':
					listenerString += `new ResizeObserver((e,o)=>${
						opts.once
							? `!o.disconnect()&&`
						: ``
					}(${toAttributeString(data)})(e[0],$$)).observe($);`
					break

				case 'observe':
					listenerString += `new MutationObserver((e,o)=>${
						opts.once
							? `!o.disconnect()&&`
						: ``
					}(${toAttributeString(data)})(e[0])).observe($,${
						opts.all ?
								`attributes: true, childList: true, subtree: true, characterData: true`
						: opts.attr ?
							`attributes: true`
						: opts.children ?
							`childList: true`
						: opts.sub ?
							`subtree: true`
						: opts.data ?
							`characterData:true`
						: `attributes: true, childList: false, subtree: false, characterData: false`
						});`
					break

				case 'visible':
					listenerString += `new IntersectionObserver((e,o)=>e[0].isIntersecting${
						opts.once
							? `&&!o.disconnect()`
						: ``
					}&&(${toAttributeString(data)})(e[0],$$)).observe($);`
					break

				default:
					listenerString += `$.addEventListener(${toAttributeString(`"${type}"`)},${
						opts.prevent
							? `e=>{e.preventDefault();(${toAttributeString(data)})(e,$$)}`
						: toAttributeString(data)
					}${
						opts.once
						? ',{once:true}'
						: opts.useCapture
						? `,{useCapture:true}`
						: ''
					});`
			}
		} else if (name.includes('@animate') && data && typeof data === 'object') {
			/** Applying Web Animate API to the Element */
			const [ keyFrames, options ] = [
				attrs['@animate'],
				attrs['@animateOptions']
			]
			delete attrs['@animate']
			delete attrs['@animateOptions']

			listenerString += `$.animate(${toAttributeString(JSON.stringify(keyFrames))},${toAttributeString(JSON.stringify({...options}))});`
		}
	}
}

const onLoadString: string = listenerString || listenerOfOnce ? `(function(){let $=this,$$=(await import("${dataURI}")).default, fetch = window.fetch;${
	listenerString
};${
	listenerOfOnce
}}).call(this.previousSibling,this.remove())` : null

---

<XElement {...attrs}><slot /></XElement>{
	onLoadString && <script type="module" src={dataURI} onload={onLoadString}></script>
}